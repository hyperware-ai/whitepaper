\documentclass[runningheads]{llncs}
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter
%
\usepackage{listings}
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
\usepackage{hyperref}
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Kinode: Offchain Cloud Computing Stack}
%
\titlerunning{Kinode}
%
\author{doria % \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}
}
%
% \authorrunning{doria}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{ }
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Kinode is a software platform built and maintained to integrate all the facets of modern crypto application development.
The node-based cloud computing model enabled by Kinode will at long last bridge the impedance mismatch between onchain protocols and web services.
Users can run their own services both at the interface and backend level, and corporations or entities can provide services in a permissionless, protocolized manner.
Developers can write apps in any programming language that compiles to Wasm, then distribute them to sovereign users.
Kinode is a lot of things:
Along with being the Kinode Operating System, Kinode is also an onchain namespace, utility token for governing and assigning value to that namespace, fully-onchain PKI (Public-Key Infrastructure), and a DAO that controls both onchain assets and continued development of the OS.
All of these aspects work in lockstep to solve the problems that have heretofore discouraged developers from using p2p computing.

\keywords{Operating System \and Decentralized \and Cloud \and Wasm \and Cryptocurrency \and Public-Key Infrastructure \and Namespace \and Peer-to-Peer }
\end{abstract}
%
%
%
\tableofcontents
\newpage
%
%
%
\section{Kimap}
\verb|kimap| is an onchain key-value store inspired by \href{https://github.com/dapphub/dmap}{dmap}, a minimalist onchain path-formatted key-value store.
It serves as the base-level shared global state that all nodes use to share critical data to the entire network.
Like dmap, kimap is organized as a hierarchical path system and has mutable/immutable keys.
Several aspects of the map implementation are customized for the 'namespace' use case.
However, the most important details that enable dmap to be read from and verified easily remain in place.

Historically, discoverability of both \textit{peers} and \textit{content} has been a major barrier for developers seeking to build peer-to-peer.
This issue rears its head in scenarios both social and purely technical: finding a new user to chat or play a game with, or a node's software acquiring the actual networking information for a username given out-of-band.
Many solutions have been designed to address this problem or aspects of it, but so far, the "devex" (developer experience) of deploying centralized services has continued to outcompete the p2p discoverability options available.
Why is this?
\begin{itemize}
    \item Libraries such as \verb|libp2p|, while effective at their goal of providing p2p primitives, do not provide the "batteries included" identity / discoverability / network-effect-potential of more traditional centralized alternatives, and can also be difficult to approach for new developers.
    \item "Pure" peer-to-peer protocols still rely on hardcoded lists to bootstrap new entrants.
    \item Constructs such as distributed hash tables, frequently used in p2p protocols, are complex to properly implement.
\end{itemize}
We believe that in order for decentralized software to out-compete, it must be both easier to reason about (for a developer) and more effective at delivering some desirable user experience.
Developers must be able to easily reason about software in order to effectively build on it, and building on existing software is how growth begins to compound.
This principle drives the design of kimap.
\begin{itemize}
    \item All globally-shared data must be \textit{in one place}.
    This property ensures that a full, up-to-date snapshot data can be read easily.
    \item In our case, that "one place" is onchain inside a single smart contract.
    \item All data necessary to bootstrap peer-to-peer interaction must be made available within the globally-shared map.
    \item Any "missing piece" required to complete handshakes or source peers will result in unreliability and re-centralization.
\end{itemize}

With this in mind, the following specification describes kimap:
All keys are strings containing exclusively characters 0-9, a-z (lowercase), and - (hyphen).
Every key has an owner address, which can be a contract or an EOA. The owner address can transfer the key to a new owner and mint keys directly below the key in the path hierarchy. For example, if a wallet owns \verb|mypath.network|, that wallet can mint \verb|hello.mypath.network|.

An entry may be created with the prefix \verb|~|. Such keys may not have keys minted beneath them: they are terminal nodes. The prefix denotes that such keys are used to store a bytes payload of readable data. The format of the stored data is determined on a protocol-by-protocol basis depending on the key name. Any valid key name with the tilde-prefix may store data.

\begin{figure}
    \centering
    \begin{lstlisting}
    os
        foo
            ~ip
            ~ws-port
            ~net-key
        bar
            ~routers
            ~net-key
    kino
        baz
            package
               ~publisher
               ~hash
               ~name
                ~mirrors
    eth
        alice
            ~routers
            ~net-key
        bob
            ~routers
            ~net-key
    \end{lstlisting}
    \caption{Example kimap}
    \label{fig:example kimap}
\end{figure}

There are 3 top-level namespace entries in the example, \verb|eth|, \verb|kino|, and \verb|os|.
Below those are a number of namespace entries that can be considered "domains", such as \verb|foo|, \verb|bar|, \verb|baz|.
The full path for \verb|foo|'s \verb|~ip| sub-entry would be \verb|~ip.foo.os|.
In this paper, we will sometimes use the term "domain" interchangeably with what is referred to here as a "namespace entry".
This is a useful shorthand, and in many ways, kimap does mirror the role of DNS in the worldwide web.
However, this analogy would be inaccurate if applied directly to all namespace entries.

In the above example, one can see a number of entries which have \verb|~net-key| as a sub-entry.
This identifies the entry as participating in the KNS (Kinode Name System) protocol \textit{on top} of the kimap.
Hopefully this makes it clear as to why "domain" is a potentially confusing term to describe any given kimap entry.
Entries \verb|baz.kino| and \verb|package.baz.kino| have no sub-entries to describe their status as a domain in the KNS.
The design of kimap is generic in the sense that many protocols are expected to share this global namespace for different purposes.
The specification of KNS itself, as a protocol within this namespace, is described in its own chapter, as is the specification of the Kinode Package Manager which makes an appearance in this example.

\subsection{Top-Level Domains}

Entries at the top level of kimap, with no parent entry, can be considered Top-Level Domains.
TLDs may not store data using the \verb|~| prefix.

Minting of new TLDs in kimap is permissioned.
Top level entries are valuable, because they produce new namespaces that can be applied to new protocols, entities, or individuals.
Allowing new TLDs to be created freely would lead to name-squatting and other perils clearly demonstrated by the history of similar namespaces.
Instead, the distribution of TLDs over time is one of the key responsibilities of Kinode's governance apparatus, described in the Kinode DAO chapter.

Since every entry can be owned by a contract, different control logic can be reliably implemented at the ownership level.
At first launch of kimap, a few selected TLDs will have ownership transferred to immutable contracts.
Other TLDs will be time-locked in contracts, acting as a rent mechanism.

\subsection{Namespace Hierarchy}

Each entry in kimap has write access to all of its sub-entries, at any level of nesting.
Even if \verb|package.baz.kino| is minted and transferred to different owner than \verb|baz.kino|, which itself is owned by a different address than \verb|kino|, the owner of \verb|kino| may transfer or edit data stored at \verb|~hash.package.baz.kino|.
There are two ways for the owner of a non-top-level entry to ensure control over their namespace entry: parent entries can be owned by an inert address (0x00..00, etc) or owned by a contract which is programmatically incapable of mutating their entry.

This property enables arbitrarily complex logic governing different sub-namespaces of kimap.
A given namespace can be owned by a contract which implements rent logic, requiring regular payments for control over a sub-entry.
Or, an owner contract could dynamically re-allocate sub-entries as temporary or permanent rewards for auctions, gameplay, or other onchain activities.
We anticipate and welcome these experimental outcomes.

As part of Kinode DAO's responsibilities in guaranteeing the utility and reliability of the protocol, certain namespaces will be given over to immutable contracts at launch.
The \verb|os| TLD, for example, will be controlled by a contract that allows any sub-entry to be minted freely, by anyone, and owned forever.
To prevent name squatting and generally dilute the value of this "namespace of last resort", minted sub-entries are required to be 9 or more characters long.
This also serves as a good example of the kind of custom logic a namespace may implement.

\subsection{Storing Data at Terminal Nodes}

At any level below the top in the kimap path hierarchy, a new key may be minted with the \verb|~| (tilde) prefix to signify that it stores a value.

Entries of this variety \textbf{may not} mint sub-entries, hence the prefix: one can use \verb|~my-data.hello.os| to store data while minting \verb|my-data.hello.os| in order to mint sub-entries beneath it, should one desire to do so.

Data is stored as bytes inside the contract map.
The owner of a namespace entry is the only address that can modify the data stored at that entry.
The interpretation of stored bytes is the responsibility of the protocol reading and writing from that entry.
Data can be mutable or immutable.
All data is public.
Protocols that wish to operate on private data may store hashes at namespace entries, or alternatively operate within the end-to-end encrypted Kinode networking protocol.

\subsection{Ownership and Transferring}

TODO

\subsection{Token-Bound Accounts}

Each namespace entry that does not store data, i.e. does not have a \verb|~| prefix, is a \href{https://eips.ethereum.org/EIPS/eip-6551}{token-bound account}.
This means that namespace entries are automatically endowed with a wallet, controlled by their owner, for receiving, holding, and sending digital assets that live on the same chain as kimap.
The address of each entry's token-bound account is deterministic based on the path value.
Thus, before a path is even minted, one can send assets to its future wallet address or otherwise operate on it.

\subsubsection{Creation and Use}

TODO

\subsection{Extensibility}

Kimap is designed to be generic and extensible.
Protocols such as KNS and the Kinode Package Manager extend kimap by placing special consideration on certain keys and interpreting the data stored at them in a particular way.
A specific description of how this works can be seen in the chapters for each of those protocols.

In the general case, a protocol specifies itself on kimap by declaring a set of \verb|~|-prefixed keys which are interpreted a certain way and endow certain properties to their parent key. For example, a protocol that aims to act as an motd ("message of the day") system may specify that the bytes stored at any \verb|~motd| key will be interpreted as a UTF-8 motd string for the parent key, which is perhaps a node identity in the KNS. If the owner of the key \verb|howdy.kino| wishes to participate in this protocol, it simply mints the key \verb|~motd.howdy.kino| and stores bytes there, perhaps \verb|[68 65 6c 6c 6f 20 77 6f 72 6c 64]|.

Extension of kimap is permissionless: any protocol may begin operating on the keys and data stored in the map simply by specifying itself.
Note that if two protocols use the same entry or entries to store data, key owners may be forced to choose between participating in one protocol or the other.
If an entry label is already in use by a popular protocol, developers creating a new protocol would be advised to either match the data format in current use for that entry label, or ensure non-overlap by prefixing/postfixing the entry label with a custom value.
For example, if the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it instead reads that label from \verb|~my-protocol-motd.howdy.kino|.

Another strategy for avoiding conflicts is to subdivide the namespace by storing a protocol's data entries at a nested path beneath the relevant entry.
If the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it reads that label from \verb|~motd.my-protocol.howdy.kino| rather than directly below.

%
%
%
\section{KNS, Kinode Name System}

Kinode Name System is a protocol built on top of kimap.
It transforms an entry in the kimap namespace into a \textit{node identity} for use in the Kinode network.
Node identities are central to the programming model of Kinode OS.
Usually manipulated as strings in a process, a node's identity is the first component of an \verb|address|, which uniquely identifies a specific process, part of a package, published by a (different) \verb|node_id|, running on that particular node.

\subsection{Specification}

The definition of a node identity in the KNS protocol is any kimap entry which has a:

\verb|~net-key| sub-entry AND (a \verb|~routers| sub-entry XOR (an \verb|~ip| sub-entry AND at least one of the following: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry)).

A sample of this protocol can be seen in fig. \ref{fig:example kimap}. Two classes of nodes are defined: \textit{direct} and \textit{indirect}. Direct nodes are those which publish an \verb|~ip| and one or more of the \verb|port| sub-entries. Indirect nodes are those which publish \verb|~routers|.

The data stored at \verb|~net-key| must be 32 bytes corresponding to an Ed25519 public key.
This is a node's signing key which is used across a variety of domains to verify ownership, including in the end-to-end encrypted networking protocol between nodes.
The owner of a namespace entry / node identity may rotate this key at any time by posting a transaction to kimap mutating the data stored at \verb|~net-key|.

The bytes at a \verb|~routers| entry must parse [TODO what encoding?] to an array of strings.
These strings should be node identities.
Each node in the array is treated by other participants in the networking protocol as a router for the parent entry.
Routers should themselves be direct nodes.
If a string in the array is not a valid node identity, or it is a valid node identity but not a direct one, that router will not be effective in the networking protocol.
Further discussion of the networking protocol specification is presented in the Networking section of the Kinode OS chapter.

The bytes at an \verb|~ip| entry must be 16 bytes corresponding [TODO clarify little or big endian] to a 128-bit unsigned integer.
This integer is translated to an IPv4 address if it is <32-bit.
Otherwise it is translated to an IPv6 address. [TODO clarify translation process]

Lastly, the bytes at any of the following port entries: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry must be 2 bytes corresponding to a 16-bit unsigned integer [TODO clarify little or big endian].
This integer is translated to a port number.
In practice, port numbers used are between 9000 and 65535.
Ports between 8000-8999 are usually saved for HTTP server use.

\subsection{Indexing}

[TODO]

\subsection{Adding other onchain identity primitives}

The KNS is not an attempt at replacing or competing with existing onchain identity primitives such as ENS and Lens.
Rather, it is designed to satisfy the public key infrastructure needs of the Kinode network.
It is of paramount importance that nodes can initiate secure communication with one another without the use of any data-set other than what is available publicly onchain.
Peer-discovery middlemen induce centralization and complicate networking protocols.

The structure of kimap means that not only can KNS be designed not to compete with other identity primitives, it can also seamlessly integrate them.
As of this paper, this has already been done for ENS protocol.
Here is a brief description of the procedure to do so:
\begin{enumerate}
    \item A contract is created to allow owners, and only owners, of a given identity primitive to mint their corresponding name in a kimap namespace controlled by this contract.
    \item The top-level namespace entry corresponding to an outside identity primitive, \verb|lens| for example, is minted and transferred to this contract.
    \item If necessary, a LayerZero or other such cross-chain messaging protocol is configured to allow owners of an identity primitive on another chain to verify their ownership on the chain that kimap is deployed on.
    \item The final result is that the owner of, for example, \verb|myname.lens| can now register \verb|myname.lens| in kimap and use it as their PKI entry for Kinode.
\end{enumerate}

%
%
%
\section{Kinode OS}

Note: for a more "hands-on" description of the OS, go to \href{https://book.kinode.org/r}{book.kinode.org}.

Kinode OS is a process virtual machine run to operate a "node" on the Kinode network.
After a node identity is registered onchain in the KNS, the operator should boot the OS using the private key matching the public \verb|~net-key| posted in the kimap.
Once this has been done, if the networking details (routers, IP, etc) are properly read from chain and able to be matched by the runtime, that node is now "online".
Other nodes will now be able to interact with the booted node.

The virtual machine is developed and distributed by Kinode DAO.
A reference implementation will be maintained, and a formal specification of all aspects of the virtual machine is currently under development.
In the future, Kinode will benefit from "client diversity" as does a traditional blockchain: many implementations of the virtual machine will make the network more robust to potential bugs and decentralize the development process, which leads to productive ossification of core features, resulting in stability and long-term strength.

[TODO this whole section]

\subsection{Microkernel}
\subsection{Message passing}
\subsection{WIT definition and process format}
\subsection{Example process}
\subsection{Capabilities-based security}
\subsection{System Primitives}
\subsubsection{Virtual filesystem}
\subsubsection{Networking}
\subsubsection{HTTP client \& server}
\subsubsection{ETH RPC access}
\subsubsection{SQLite, KV-store}
\subsection{Runtime extensions}
\subsection{Backwards compatibility}
%
%
%
\section{Package Manager}
\subsection{Specification}
\subsection{Default-distro app: App Store}
%
%
%
\section{KINO Token}

\$KINO is a utility token designed to fill two roles in the Kinode network: assignment of \textbf{relative value in the global namespace} and \textbf{governance}.

As described in its chapter, kimap addresses the discoverability problem in peer-to-peer programming by allowing participants to claim paths and post data to a global hierarchical namespace.
However, this mass of bytes is near-useless without a \textit{weighting mechanism} that can be used programmatically or manually to evaluate content for relative value.

Decentralized finance protocols generally benefit from maximal immutability: once a stable and useful primitive exists, its value only tends to decay with changes.
For this reason, "governance" as applied to purely onchain protocols has historically been somewhat weak.
There is no governance necessary if a protocol is truly immutable and permissionless. \textbf{Kinode is not a purely onchain protocol}, however, and has a significant governance burden which must be executed in a decentralized matter for the network to be stable, neutral, and permissionless.

\subsection{Binding to kimap namespace}
\subsection{Unbinding}
\subsection{Rewards}
\subsection{Emissions}
\subsection{Future uses}
%
%
%
\section{veKINO "vote-escrow" Token}
\subsection{Voting and Rewards}
\subsection{Emissions}
\subsection{Default-distro app: Governance Portal}
%
%
%
\section{Kinode DAO}
\subsection{Governance structure}
\subsection{Proposals and voting}
\subsection{TLD management}
\subsubsection{Auction Types}
\subsubsection{Profitability}
%
%
%
\section{A Kinode Future}
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
%\begin{thebibliography}{8}
%\bibitem{ref_article1}
%Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)
%
%\bibitem{ref_lncs1}
%Author, F., Author, S.: Title of a proceedings paper. In: Editor,
%F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
%Springer, Heidelberg (2016). \doi{10.10007/1234567890}
%
%\bibitem{ref_book1}
%Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
%Location (1999)
%
%\bibitem{ref_proc1}
%Author, A.-B.: Contribution title. In: 9th International Proceedings
%on Proceedings, pp. 1--2. Publisher, Location (2010)
%
%\bibitem{ref_url1}
%LNCS Homepage, \url{http://www.springer.com/lncs}, last accessed %2023/10/25
%\end{thebibliography}
\end{document}
