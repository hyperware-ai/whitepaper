\documentclass[runningheads]{llncs}
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter
%
\usepackage{listings}
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
\usepackage{hyperref}
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Kinode: Offchain Cloud Computing Stack}
%
\titlerunning{Kinode}
%
\author{doria % \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}
}
%
% \authorrunning{doria}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{ }
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
This paper describes Kinode, a software platform built and maintained to integrate all the facets of modern crypto application development.
The node-based cloud computing model enabled by Kinode will at long last bridge the impedance mismatch between onchain protocols and web services.
Users can run their own services both at the interface and backend level, and corporations or entities can provide services in a permissionless, protocolized manner.
Developers can write apps in any programming language that compiles to Wasm, then distribute them to sovereign users.
Kinode is a lot of things:
Along with being the Kinode Operating System, Kinode is also an onchain namespace, utility token for governing and assigning value to that namespace, fully-onchain PKI (Public-Key Infrastructure), and a DAO that controls both onchain assets and continued development of the OS.
All of these aspects work in lockstep to solve the problems that have heretofore discouraged developers from using peer-to-peer computing.

\keywords{Operating System \and Decentralized \and Cloud \and Wasm \and Cryptocurrency \and Public-Key Infrastructure \and Namespace \and Peer-to-Peer }
\end{abstract}
%
%
%
\tableofcontents
\newpage
%
%
%
\section{Kimap}
\verb|kimap| is an onchain key-value store inspired by \href{https://github.com/dapphub/dmap}{dmap}, a minimalist onchain path-formatted key-value store.
It serves as the base-level shared global state that all nodes use to share critical data to the entire network.
Like dmap, kimap is organized as a hierarchical path system and has mutable/immutable keys.
Several aspects of the map implementation are customized for the 'namespace' use case.
However, the most important details that enable dmap to be read from and verified easily remain in place.

Historically, discoverability of both \textit{peers} and \textit{content} has been a major barrier for developers seeking to build peer-to-peer.
This issue rears its head in scenarios both social and purely technical: finding a new user to chat or play a game with, or a node's software acquiring the actual networking information for a username given out-of-band.
Many solutions have been designed to address this problem or aspects of it, but so far, the "devex" (developer experience) of deploying centralized services has continued to outcompete the p2p discoverability options available.
Why is this?
\begin{itemize}
    \item Libraries such as \verb|libp2p|, while effective at their goal of providing p2p primitives, do not provide the "batteries included" identity / discoverability / network-effect-potential of more traditional centralized alternatives, and can also be difficult to approach for new developers.
    \item "Pure" peer-to-peer protocols still rely on hardcoded lists to bootstrap new entrants.
    \item Constructs such as distributed hash tables, frequently used in p2p protocols, are complex to properly implement.
\end{itemize}
We believe that in order for decentralized software to out-compete, it must be both easier to reason about (for a developer) and more effective at delivering some desirable user experience.
Developers must be able to easily reason about software in order to effectively build on it, and building on existing software is how growth begins to compound.
This principle drives the design of kimap.
\begin{itemize}
    \item All globally-shared data must be \textit{in one place}.
    This property ensures that a full, up-to-date snapshot data can be read easily.
    \item In our case, that "one place" is onchain inside a single smart contract.
    \item All data necessary to bootstrap peer-to-peer interaction must be made available within the globally-shared map.
    \item Any "missing piece" required to complete handshakes or source peers will result in unreliability and re-centralization.
\end{itemize}

With this in mind, the following specification describes kimap:
All keys are strings containing exclusively characters 0-9, a-z (lowercase), - (hyphen), and \_ (underscore) [TODO maybe not underscore? need to be compatible with existing app names though..].
An entry is a path made of ordered keys.
Every key has an owner address, which can be a contract or an EOA. The owner address can transfer the key to a new owner and mint keys directly below the key in the path hierarchy. For example, if a wallet owns \verb|mypath.network|, that wallet can mint \verb|hello.mypath.network|.

Every kimap entry is an ERC-721 NFT (non-fungible token).
Thus, every kimap entry is a unique transferable onchain asset with a known ownership history.

A key may be minted with the prefix \verb|~|. Such keys may not have keys minted beneath them: they are terminal nodes. The prefix denotes that such keys are used to store a bytes payload of readable data. The format of the stored data is determined on a protocol-by-protocol basis depending on the key name. Any valid key name with the tilde-prefix may store data.

\begin{figure}
    \centering
    \begin{lstlisting}
    os
        foo
            ~ip
            ~ws-port
            ~net-key
        bar
            ~routers
            ~net-key
    kino
        baz
            package
                ~metadata-hash
                ~metadata-uri
    eth
        alice
            ~routers
            ~net-key
        bob
            ~routers
            ~net-key
    \end{lstlisting}
    \caption{Example kimap.}
    \label{fig:example kimap}
\end{figure}

There are 3 top-level namespace entries in the example, \verb|eth|, \verb|kino|, and \verb|os|.
Below those are a number of namespace entries that can be considered "domains", such as \verb|foo|, \verb|bar|, \verb|baz|.
The full path for \verb|foo|'s \verb|~ip| sub-entry would be \verb|~ip.foo.os|.
In this paper, we will sometimes use the term "domain" interchangeably with what is referred to here as a "namespace entry".
This is a useful shorthand, and in many ways, kimap does mirror the role of DNS in the worldwide web.
However, this analogy would be inaccurate if applied directly to all namespace entries.

In the above example, one can see a number of entries which have \verb|~net-key| as a sub-entry.
This identifies the entry as participating in the KNS (Kinode Name System) protocol \textit{on top} of the kimap.
Hopefully this makes it clear as to why "domain" is a potentially confusing term to describe any given kimap entry.
Entries \verb|baz.kino| and \verb|package.baz.kino| have no sub-entries to describe their status as a domain in the KNS.
The design of kimap is generic in the sense that many protocols are expected to share this global namespace for different purposes.
The specification of KNS itself, as a protocol within this namespace, is described in its own chapter, as is the specification of the Kinode Package Manager which makes an appearance in this example.

\subsection{Top-Level Domains}

Entries at the top level of kimap, with no parent entry, can be considered Top-Level Domains.
TLDs may not store data using the \verb|~| prefix.

Minting of new TLDs in kimap is permissioned.
Top level entries are valuable, because they produce new namespaces that can be applied to new protocols, entities, or individuals.
Allowing new TLDs to be created freely would lead to name-squatting and other perils clearly demonstrated by the history of similar namespaces.
Instead, the distribution of TLDs over time is one of the key responsibilities of Kinode's governance apparatus, described in the Kinode DAO chapter.

Since every entry can be owned by a contract, different control logic can be reliably implemented at the ownership level.
At first launch of kimap, a few selected TLDs will have ownership transferred to immutable contracts.
Other TLDs will be time-locked in contracts, acting as a rent mechanism.

\subsection{Namespace Hierarchy}

Each entry in kimap has write access to all of its sub-entries, at any level of nesting.
Even if \verb|package.baz.kino| is minted and transferred to different owner than \verb|baz.kino|, which itself is owned by a different address than \verb|kino|, the owner of \verb|kino| may transfer or edit data stored at \verb|~metadata-hash.package.baz.kino|.
There are two ways for the owner of a non-top-level entry to ensure control over their namespace entry: parent entries can be owned by an inert address (0x00..00, etc) or owned by a contract which is programmatically incapable of mutating their entry.

This property enables arbitrarily complex logic governing sub-namespaces of kimap.
A given namespace can be owned by a contract which implements rent logic, requiring regular payments for control over a sub-entry.
Or, an owner contract could dynamically re-allocate sub-entries as temporary or permanent rewards for auctions, gameplay, or other onchain activities.
We anticipate and welcome these experimental outcomes.

As part of Kinode DAO's responsibilities in guaranteeing the utility and reliability of the protocol, certain namespaces will be given over to immutable contracts at launch.
The \verb|os| TLD, for example, will be controlled by a contract that allows any sub-entry to be minted freely, by anyone, and owned forever.
To prevent name squatting and generally dilute the value of this "namespace of last resort", minted sub-entries are required to be 9 or more characters long.
This also serves as a good example of the kind of custom logic a namespace may implement.

\subsection{Storing Data At Terminal Nodes}

At any level below the top in the kimap path hierarchy, a new key may be minted with the \verb|~| (tilde) prefix to signify that it stores a value.

Entries of this variety \textbf{may not} mint sub-entries, hence the prefix: one can use \verb|~my-data.hello.os| to store data while minting \verb|my-data.hello.os| in order to mint sub-entries beneath it, should one desire to do so.

Data is stored as bytes inside the contract map.
The owner of a namespace entry is the only address that can modify the data stored at that entry.
The interpretation of stored bytes is the responsibility of the protocol reading and writing from that entry.
Data can be mutable or immutable.
All data is public.
Protocols that wish to operate on private data may store hashes at namespace entries, or alternatively operate within the end-to-end encrypted Kinode networking protocol.

\subsection{Ownership and Transferring}

TODO

\subsection{Token-Bound Accounts}

Each namespace entry that does not store data, i.e. does not have a \verb|~| prefix, is a \href{https://eips.ethereum.org/EIPS/eip-6551}{token-bound account}.
This means that namespace entries are automatically endowed with a wallet, controlled by their owner, for receiving, holding, and sending digital assets that live on the same chain as kimap.
The address of each entry's token-bound account is deterministic based on the path value.
Thus, before a path is even minted, one can send assets to its future wallet address or otherwise operate on it.

\subsubsection{Creation and Use}

TODO

\subsection{Extensibility}

Kimap is designed to be generic and extensible.
Protocols such as KNS and the Kinode Package Manager extend kimap by placing special consideration on certain keys and interpreting the data stored at them in a particular way.
A specific description of how this works can be seen in the chapters for each of those protocols.

In the general case, a protocol specifies itself on kimap by declaring a set of \verb|~|-prefixed keys which are interpreted a certain way and endow certain properties to their parent key. For example, a protocol that aims to act as an motd ("message of the day") system may specify that the bytes stored at any \verb|~motd| key will be interpreted as a UTF-8 motd string for the parent key, which is perhaps a node identity in the KNS. If the owner of the key \verb|howdy.kino| wishes to participate in this protocol, it simply mints the key \verb|~motd.howdy.kino| and stores bytes there, perhaps \verb|[68 65 6c 6c 6f 20 77 6f 72 6c 64]|.

Extension of kimap is permissionless: any protocol may begin operating on the keys and data stored in the map simply by specifying itself.
Note that if two protocols use the same entry or entries to store data, key owners may be forced to choose between participating in one protocol or the other.
If an entry label is already in use by a popular protocol, developers creating a new protocol would be advised to either match the data format in current use for that entry label, or ensure non-overlap by prefixing/postfixing the entry label with a custom value.
For example, if the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it instead reads that label from \verb|~my-protocol-motd.howdy.kino|.

Another strategy for avoiding conflicts is to subdivide the namespace by storing a protocol's data entries at a nested path beneath the relevant entry.
If the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it reads that label from \verb|~motd.my-protocol.howdy.kino| rather than directly below.

%
%
%
\section{KNS, Kinode Name System}

Kinode Name System is a protocol built on top of kimap.
It transforms an entry in the kimap namespace into a \textit{node identity} for use in the Kinode network.
Node identities are central to the programming model of Kinode OS.
Usually manipulated as strings in a process, a node's identity is the first component of an \verb|address|, which uniquely identifies a specific process, part of a package, published by a (different) \verb|node_id|, running on that particular node.

\subsection{Specification}

The definition of a node identity in the KNS protocol is any kimap entry which has a:

\verb|~net-key| sub-entry AND (a \verb|~routers| sub-entry XOR (an \verb|~ip| sub-entry AND at least one of the following: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry)).

A sample of this protocol can be seen in fig. \ref{fig:example kimap}. Two classes of nodes are defined: \textit{direct} and \textit{indirect}. Direct nodes are those which publish an \verb|~ip| and one or more of the \verb|port| sub-entries. Indirect nodes are those which publish \verb|~routers|.

The data stored at \verb|~net-key| must be 32 bytes corresponding to an Ed25519 public key.
This is a node's signing key which is used across a variety of domains to verify ownership, including in the end-to-end encrypted networking protocol between nodes.
The owner of a namespace entry / node identity may rotate this key at any time by posting a transaction to kimap mutating the data stored at \verb|~net-key|.

The bytes at a \verb|~routers| entry must parse [TODO what encoding?] to an array of strings.
These strings should be node identities.
Each node in the array is treated by other participants in the networking protocol as a router for the parent entry.
Routers should themselves be direct nodes.
If a string in the array is not a valid node identity, or it is a valid node identity but not a direct one, that router will not be effective in the networking protocol.
Further discussion of the networking protocol specification is presented in the Networking section of the Kinode OS chapter.

The bytes at an \verb|~ip| entry must be 16 bytes corresponding [TODO clarify little or big endian] to a 128-bit unsigned integer.
This integer is translated to an IPv4 address if it is <32-bit.
Otherwise it is translated to an IPv6 address. [TODO clarify translation process]

Lastly, the bytes at any of the following port entries: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry must be 2 bytes corresponding to a 16-bit unsigned integer [TODO clarify little or big endian].
This integer is translated to a port number.
In practice, port numbers used are between 9000 and 65535.
Ports between 8000-8999 are usually saved for HTTP server use.

\subsection{Indexing}

[TODO]

\subsection{Adding Other Onchain Identity Primitives}

The KNS is not an attempt at replacing or competing with existing onchain identity primitives such as ENS and Lens.
Rather, it is designed to satisfy the public key infrastructure needs of the Kinode network.
It is of paramount importance that nodes can initiate secure communication with one another without the use of any data-set other than what is available publicly onchain.
Peer-discovery middlemen induce centralization and complicate networking protocols.

The structure of kimap means that not only can KNS be designed not to compete with other identity primitives, it can also seamlessly integrate them.
As of this paper, this has already been done for ENS protocol.
Here is a brief description of the procedure to do so:
\begin{enumerate}
    \item A contract is created to allow owners, and only owners, of a given identity primitive to mint their corresponding name in a kimap namespace controlled by this contract.
    \item The top-level namespace entry corresponding to an outside identity primitive, \verb|lens| for example, is minted and transferred to this contract.
    \item If necessary, a LayerZero or other such cross-chain messaging protocol is configured to allow owners of an identity primitive on another chain to verify their ownership on the chain that kimap is deployed on.
    \item The final result is that the owner of, for example, \verb|myname.lens| can now register \verb|myname.lens| in kimap and use it as their PKI entry for Kinode.
\end{enumerate}

%
%
%
\section{Kinode OS}

Note: for a more "hands-on" description of the OS, go to \href{https://book.kinode.org/r}{book.kinode.org}.

Kinode OS is a process virtual machine run to operate a "node" on the Kinode network.
After a node identity is registered onchain in the KNS, the operator should boot the OS using the private key matching the public \verb|~net-key| posted in the kimap.
Once this has been done, if the networking details (routers, IP, etc) are properly read from chain and able to be matched by the runtime, that node is now "online".
Other nodes will now be able to interact with the booted node.

The virtual machine is developed and distributed by Kinode DAO.
A reference implementation will be maintained, and a formal specification of all aspects of the virtual machine is currently under development.
In the future, Kinode will benefit from "client diversity" as does a traditional blockchain: many implementations of the virtual machine will make the network more robust to potential bugs and decentralize the development process, which leads to productive ossification of core features, resulting in stability and long-term strength.

While (generally) all packaged into a single executable, the OS can productively be described in 3 parts: a \textit{runtime}, a set of \textit{runtime modules}, and \textit{userspace}.
The "kernel" frequently referred to in this paper is in fact just a runtime module.

The runtime is a "native" (to whatever architecture it targets, which may be Unix, a browser, hardware...) program that manages node booting (including onchain registration) and (generally asynchronously or in parallel) executes the runtime modules.
Runtime modules are blocks of code written at the same level of abstraction as the runtime itself, but designed to resemble userspace processes.
These modules are registered in the kernel \textit{as} processes, meaning that they can be messaged by userspace in the system-wide request-response protocol and secured via capabilities.
Finally, userspace is comprised of all non-runtime-module processes executed virtually by the kernel.
These processes are always compiled to Wasm and comport to the Wasm Component Model\footnote{https://component-model.bytecodealliance.org/}.
They are adapted to the Kinode WIT file which defines the common interface that all processes must implement and provides a set of "system calls" afforded to userspace processes by the kernel.

\subsection{Microkernel}

As of this writing, the microkernel\footnote{https://wiki.osdev.org/Microkernel} runtime module in Kinode DAO's implementation of the OS fits into about 2,700 lines of Rust.

\begin{figure}
    \centering
    \begin{lstlisting}
    eth:distro:sys
    http_client:distro:sys
    http_server:distro:sys
    kernel:distro:sys
    kv:distro:sys
    net:distro:sys
    state:distro:sys
    terminal:distro:sys
    timer:distro:sys
    sqlite:distro:sys
    vfs:distro:sys
    \end{lstlisting}
    \caption{The full list of runtime modules in the OS distribution maintained by Kinode DAO.}
    \label{fig:runtime modules list}
\end{figure}

\subsection{Message Passing}
\subsection{WIT Definition and Process Format}
\subsection{Example Process}
\subsection{Capabilities-Based Security}
\subsection{System Primitives}
\subsubsection{Virtual Filesystem}
\subsubsection{Networking}
\subsubsection{HTTP Client \& Server}
\subsubsection{ETH RPC}
\subsubsection{SQLite, KV-Store}
\subsection{Runtime Extensions}
\subsection{Backwards Compatibility}
%
%
%
\section{Package Manager}

Like KNS, the Kinode Package Manager is a protocol deployed on kimap.
It is another protocol critical to the operation of Kinode OS.
As described in the Kinode OS chapter, the userspace presented by the OS is comprised of processes, which are bundled into packages.
There is no built-in method for managing the packages installed in a node.
Rather, userspace programs with the required capabilities must save packages in the virtual filesystem and prompt the kernel to start running certain processes.
The kernel has no built-in concept of a "package".

If a process has the necessary capabilities, they may create requests to and receive responses from \verb|kernel:distro:sys| like any other process.
The kernel specifies a request type that includes commands relevant to managing processes.
Programs that wish to "install" and "uninstall" packages merely submit these requests.
These programs must also have advanced capabilities to access the virtual filesystem, such that they can create new top-level directories formatted in such a way that the kernel can access compiled \verb|.wasm| files that contain a single process.

By convention, packages are stored in a \verb|.zip| file with the name of the package (package name [colon] publisher node id).
The top level of the zipped directory contains a \verb|metadata.json| file, a \verb|pkg| directory, and a directory for each process defined in the \verb|pkg| directory.
The \verb|pkg| directory defines processes by
\begin{enumerate}
    \item containing a \verb|.wasm| file, the name of which matches the process name
    \item optionally declaring the process in a file named \verb|manifest.json|, which defines the processes in the package that should be ran upon installation.
\end{enumerate}

\verb|pkg| may also contain a \verb|scripts.json| file which defines a list of processes that can be ran as scripts.
Scripts are merely processes which, by convention, can be executed from the system terminal, run for some period of time, and optionally return a final response before exiting which the terminal may print.

It is important to note that all of the above logic exists outside of the kernel and runtime.
A package's directory, metadata, and manifest are all interpreted by userspace code and boiled down to a series of kernel commands including \verb|InitializeProcess|, \verb|RunProcess|, and \verb|KillProcess|.
Of course, Kinode OS would not be very useful without this logic, and so the distribution maintained by the DAO comes with a combination app store and package manager called \verb|app_store:sys|.
Note that the publisher name, \verb|sys|, is not a node identity.
The publisher value in a package name is not enforced by the kernel.
It is accepted uncritically, and it is again the responsibility of the userspace package manager to assert a valid publisher if desired.

\subsection{Specification}

The userspace app store / package manager maintained by Kinode DAO uses an onchain protocol running on kimap to enable app discoverability and ranking.
The definition of a package (interchangeably called an "app") in this protocol is any kimap entry which has both of the following sub-entries:

\verb|~metadata-hash|, \verb|~metadata-uri|.

The publisher name of a package is the parent-parent entry.
The package name is the last path item in the parent entry.

A \verb|~metadata-hash| entry must contain 32 bytes corresponding to a SHA-256 hash of the \verb|metadata.json| file used to install a package.

A \verb|metadata-uri| entry may contain a UTF-8 string [TODO confirm this] corresponding to a Uniform Resource Identifier where one may access the metadata file for which the hash is contained in \verb|~metadata-hash|.

\begin{figure}
    \centering
    \begin{lstlisting}
    os
        foo
            ~ip
            ~ws-port
            ~net-key
            foos-app
                ~metadata-hash
                ~metadata-uri
    kino
        bar
            baz
                ~metadata-hash
                ~metadata-uri
            bam
                ~net-key
                ~routers
                ~metadata-hash
                ~metadata-uri
                boozle
                    ~metadata-hash
                    ~metadata-uri
    \end{lstlisting}
    \caption{Example kimap with multiple packages present.}
    \label{fig:example kimap with packages}
\end{figure}

In Fig. 2 there are 4 packages present: \verb|foos-app:foo.os|, \verb|baz:bar.kino|, \verb|bam:bar.kino|, and \verb|boozle:bam.bar.kino|.
Note that the parent path from a valid package sub-entry contains the entire package name including publisher.
Note also that a publisher does not need to be a valid node identity as defined in the KNS protocol, though in practice it likely will be.
A single publisher providing multiple packages can do so by minting sub-entries corresponding to those packages' names.
Lastly, a package may also itself be a node identity as demonstrated in \verb|bam.bar.kino|.
This is a good example of how protocols in kimap's global namespace interact and overlap with one another.

\subsection{Default-distro App: App Store}

As noted, Kinode DAO's distribution of the OS comes with an app store.
This package is named \verb|app_store:sys|.
The \verb|main| process, \verb|main:app_store:sys|, indexes kimap to identify packages onchain, manages the installation of packages using kernel commands, and presents a web UI for a node operator to browse, install, and manage packages (generally labeled as "apps" in the frontend).

The app store also uses \$KINO to enable ranking and filtering of available apps.
A common failure mode of distributed networks is that content becomes saturated and global curation is impossible without re-centralization. [TODO explain]


[TODO provide spec for metadata.json, manifest.json, scripts.json]

%
%
%
\section{KINO Token}

\$KINO is a utility token designed to fill two roles in the Kinode network: assignment of \textbf{relative value in the global namespace} and \textbf{governance}.

As described in its chapter, kimap addresses the discoverability problem in peer-to-peer programming by allowing participants to claim paths and post data to a global hierarchical namespace.
However, this mass of bytes is near-useless without a \textit{weighting mechanism} that can be used programmatically or manually to evaluate content for relative value.

Decentralized finance protocols generally benefit from maximal immutability: once a stable and useful primitive exists, its value only tends to decay with changes.
For this reason, "governance" as applied to purely onchain protocols has historically been somewhat weak.
There is no governance necessary if a protocol is truly immutable and permissionless. \textbf{Kinode is not a purely onchain protocol}, however, and has a significant governance burden which must be executed in a decentralized matter for the network to be stable, neutral, and permissionless. [TODO more on this somewhere]

\subsection{Binding to kimap Namespace}

A token holder may \textit{bind} \$KINO to any entry in kimap.
Binding is performed in order to produce a value-weighted onchain directory of nodes, apps, and other content.
Every protocol built on kimap can automatically benefit from the binding of \$KINO to keys to create a rankable listing data structure and market for user attention.
Binding also begets rewards, which are assigned to the owner of the namespace entry, \textbf{not} the address which owns the bound tokens.
This mechanism allows protocols on kimap to encourage and incentivize users to bind tokens to entries that are not their own.

Binding \$KINO to a namespace entry generates \$veKINO, a non-transferable vote-escrow token, and assigns it to the owner of the bound entry.
The quantity of \$veKINO minted is quadratically related to the bound quantity of \$KINO.
As a result, the total voting power of a given namespace entry scales quadratically with the amount of \$KINO bound to it.

[insert equation used to calculate voting power]

\subsection{Unbinding}

\$KINO can be unbound at any time by the address which initially bound it.
The \$veKINO will be destroyed at the time of unbinding.
Note that due to the quorum-calculation strategy used, voting power will not immediately be destroyed by the destruction of \$veKINO, but will eventually match the distribution.

\subsection{Rewards}

Voting power scales quadratically with \$KINO bound to a given namespace entry, but rewards scale linearly.
Rewards are assigned in exchange for performing governance actions, and in the future will also be connected to other protocol activities.
Rewards are distributed from a pool that is controlled by the DAO.
The DAO is capped at a 2\% rate of \$KINO emissions to build up this pool.

\subsection{Emissions}

2\% for X years, then 0.

\subsection{Current and Future Uses}

\$KINO is currently used by both KNS and the Kinode package manager protocol to address spam, provide a ranking/sorting system, and enable value accrual.

%
%
%
\section{veKINO Token}

\$KINO can be bound to acquire \$veKINO, a vote-escrow token that allows the holder to participate in the governance of Kinode DAO. This is not an empty role -- unlike purely onchain protocols, which often fail to benefit from active governance, Kinode governance includes ongoing responsibilities over the namespace and protocol. Since the OS is not an onchain protocol, it is not immutable and does not benefit from being so. While the DAO will be strongly incentivized by builders to remain permanently backwards-compatible (meaning that protocols launched on Kinode will never be forced to apply an upgrade), additive non-breaking aspects will likely be added to the protocol on a regular basis to keep pace with the fast-moving world of software. The namespace also requires active governance in order to extract fair value from TLD holders and prevent abuse.

\subsection{Creating Proposals}

TODO

\subsection{Voting and Rewards}

TODO

\subsection{Delegation}

Rather than complicate the namespace and voting mechanisms with built-in onchain delegation, Kinode governance leverages the power of personal nodes to enable offchain vote delegation.
Users who wish to delegate their vote to another member may run software in their Kinode voting app to simply match the behavior of that other namespace entry onchain.
This allows users to be rewarded for participation while retaining full control of their vote.
The DAO (and possibly large voting entities) also has the ability to run paymaster server(s) to allow for free governance participation in this way.
Users may perform a one-time approval to execute votes through a paymaster leveraging account abstraction for “free” voting.

\subsection{Default-distro App: Governance Portal}
%
%
%
\section{Kinode DAO}
\subsection{Governance Structure}
\subsection{TLD Management}
\subsubsection{Auction Types}
\subsubsection{Profitability}
\subsection{Other Duties}
%
%
%
\section{A Kinode Future}

\end{document}
