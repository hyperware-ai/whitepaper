\documentclass[runningheads]{llncs}
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter
%
\usepackage{listings}
\usepackage{tikz}
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
\usepackage{hyperref}
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Kinode: Offchain Cloud Computing Stack}
%
\titlerunning{Kinode}
%
\author{doria % \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}
}
%
% \authorrunning{doria}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{ }
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Kinode is a software platform built and maintained to integrate all the facets of modern crypto application development.
The node-based cloud computing model enabled by Kinode bridges the impedance mismatch between onchain protocols and web services.
Users can run their own services both at the interface and backend level.
Corporations or other entities can provide services in a permissionless, protocolized manner.
Developers can write apps in any programming language that compiles to Wasm, then distribute them to sovereign users.
Kinode is a lot of things: an operating system, fully onchain namespace/global messaging primitive, utility token for governing and assigning value to that namespace, fully-onchain PKI (Public-Key Infrastructure), and a DAO that controls both onchain assets and continued development of the OS.
All of these aspects work in lockstep to solve the problems that have heretofore discouraged developers from embracing peer-to-peer computing.

\keywords{Operating System \and Decentralized \and Cloud \and Wasm \and Cryptocurrency \and Public-Key Infrastructure \and Namespace \and Peer-to-Peer }
\end{abstract}
%
%
%
\tableofcontents
\newpage
%
%
%
\section{Kimap}

Historically, discoverability of both \textit{peers} and \textit{content} has been a major barrier for developers seeking to build peer-to-peer.
Discoverability rears its head in scenarios both social and purely technical: finding a new user to chat or play a game with, or a node's software acquiring the actual networking information for a username given out-of-band.
Many solutions have been designed to address this problem or aspects of it, but so far, the "devex" (developer experience) of deploying centralized services has continued to outcompete the p2p discoverability options available.
Why is this?
\begin{itemize}
    \item Libraries such as \verb|libp2p|, while effective at their goal of providing p2p primitives, do not provide the "batteries included" identity / discoverability / network-effect-potential of more traditional centralized alternatives, and can also be difficult to approach for new developers.
    \item "Pure" peer-to-peer protocols still rely on hardcoded lists to bootstrap new entrants.
    \item Constructs such as distributed hash tables, frequently used in p2p protocols, are complex to properly implement.
\end{itemize}
We believe that in order for decentralized software to out-compete, it must be both easier to reason about (for a developer) and more effective at delivering some desirable user experience.
Developers must be able to easily reason about software in order to effectively build on it, and building on existing software is how growth begins to compound.
These principles drive the design of kimap.
\begin{itemize}
    \item All globally-shared data must be \textit{in one place}.
    This property ensures that a full, up-to-date snapshot data can be read easily.
    \item In our case, that "one place" is onchain inside a single smart contract.
    \item All data necessary to bootstrap peer-to-peer interaction must be made available within the globally-shared map.
    \item Any "missing piece" required to complete handshakes or source peers will result in unreliability and re-centralization.
\end{itemize}

Kimap is an onchain key-value store inspired by \href{https://github.com/dapphub/dmap}{dmap}, a minimalist onchain path-formatted key-value store.
It serves as the base-level shared global state that all nodes use to share critical data to the entire network.
Like dmap, kimap is organized as a hierarchical path system and has mutable/immutable keys.
Several aspects of the map implementation are customized for the "namespace" use case.
However, the most important details that enable dmap to be read from and verified easily remain in place.

With this in mind, the following specification describes kimap:

\begin{itemize}
    \item All keys are strings containing exclusively characters 0-9, a-z (lowercase), - (hyphen), and \_ (underscore) [TODO maybe not underscore? need to be compatible with existing app names though..].
    This property ensures that a full, up-to-date snapshot data can be read easily.
    \item An entry is a path made of ordered keys.
    \item Every entry has an owner address, which can be a contract or an EOA.
    \item The owner address can transfer the entry to a new owner and mint keys directly below the entry in the path hierarchy. For example, if a wallet owns \verb|mypath.network|, that wallet can mint \verb|hello.mypath.network|.
    \item Every kimap entry is an ERC-721 NFT (non-fungible token).
    Thus, each entry is a unique transferable onchain asset with a known ownership history.
\end{itemize}

A key may be minted with the prefix \verb|~|. Such keys may not have keys minted beneath them: they are terminal nodes. The prefix denotes that such keys are used to store a bytes payload of readable data. The format of the stored data is determined on a protocol-by-protocol basis depending on the key name. Any valid key name with the tilde-prefix may store data.

\begin{figure}
    \centering
    \begin{lstlisting}
    os
        foo
            ~ip
            ~ws-port
            ~net-key
        bar
            ~routers
            ~net-key
    kino
        baz
            package
                ~metadata-hash
                ~metadata-uri
    eth
        alice
            ~routers
            ~net-key
        bob
            ~routers
            ~net-key
    \end{lstlisting}
    \caption{Example kimap.}
    \label{fig:example kimap}
\end{figure}

There are 3 top-level namespace entries in the example, \verb|eth|, \verb|kino|, and \verb|os|.
Below those are a number of namespace entries that can be considered "domains", such as \verb|foo|, \verb|bar|, \verb|baz|.
The full path for \verb|foo|'s \verb|~ip| sub-entry would be \verb|~ip.foo.os|.
In this paper, we will sometimes use the term "domain" interchangeably with what is referred to here as a "namespace entry".
This is a useful shorthand, and in many ways, kimap does mirror the role of DNS in the worldwide web.
However, this analogy would be inaccurate if applied directly to all namespace entries.

In the above example, one can see a number of entries which have \verb|~net-key| as a sub-entry.
This identifies the entry as participating in the KNS (Kinode Name System) protocol \textit{on top} of the kimap.
Hopefully this makes it clear as to why "domain" is a potentially confusing term to describe any given kimap entry.
Entries \verb|baz.kino| and \verb|package.baz.kino| have no sub-entries to describe their status as a domain in the KNS.
The design of kimap is generic in the sense that many protocols are expected to share this global namespace for different purposes.
The specification of KNS itself, as a protocol within this namespace, is described in its own chapter, as is the specification of the Kinode Package Manager which makes an appearance in this example.

\subsection{Top-Level Domains}

Entries at the top level of kimap, with no parent entry, can be considered Top-Level Domains.
TLDs may not store data using the \verb|~| prefix.

Minting of new TLDs in kimap is permissioned.
Top level entries are valuable, because they produce new namespaces that can be applied to new protocols, entities, or individuals.
Allowing new TLDs to be created freely would lead to name-squatting and other perils clearly demonstrated by the history of similar namespaces.
Instead, the distribution of TLDs over time is one of the key responsibilities of Kinode's governance apparatus, described in the Kinode DAO chapter.

Since every entry can be owned by a contract, different control logic can be reliably implemented at the ownership level.
At first launch of kimap, a few selected TLDs will have ownership transferred to immutable contracts.
Other TLDs will be time-locked in contracts, acting as a rent mechanism.

Why create a new namespace, given that others exist with established network effects?
Primarily, because Kinode OS needs it.
The goal of the OS is to create a fully-integrated programming environment, and existing namespace options are simply not designed to enable this.
This does not mean the namespace must stand alone–see the section on \hyperref[sec:extensibility]{extensibility} for a description of how other namespaces may be integrated with kimap.

\subsection{Namespace Hierarchy}

Each entry in kimap has write access to all of its sub-entries, at any level of nesting.
Even if \verb|package.baz.kino| is minted and transferred to different owner than \verb|baz.kino|, which itself is owned by a different address than \verb|kino|, the owner of \verb|kino| may transfer or edit data stored at \verb|~metadata-hash.package.baz.kino|.
There are two ways for the owner of a non-top-level entry to ensure control over their namespace entry: parent entries can be owned by an inert address (0x00..00, etc) or owned by a contract which is programmatically incapable of mutating their entry.

This property enables arbitrarily complex logic governing sub-namespaces of kimap.
A given namespace can be owned by a contract which implements rent logic, requiring regular payments for control over a sub-entry.
Or, an owner contract could dynamically re-allocate sub-entries as temporary or permanent rewards for auctions, gameplay, or other onchain activities.
We anticipate and welcome these experimental outcomes.

As part of Kinode DAO's responsibilities in guaranteeing the utility and reliability of the protocol, certain namespaces will be given over to immutable contracts at launch.
The \verb|os| TLD, for example, will be controlled by a contract that allows any sub-entry to be minted freely, by anyone, and owned forever.
To prevent name squatting and generally dilute the value of this "namespace of last resort", minted sub-entries are required to be 9 or more characters long.
This also serves as a good example of the kind of custom logic a namespace may implement.

\subsection{Storing Data At Terminal Nodes}

At any level below the top in the kimap path hierarchy, a new key may be minted with the \verb|~| (tilde) prefix to signify that it stores a value.

Entries of this variety \textbf{may not} mint sub-entries, hence the prefix: one can use \verb|~my-data.hello.os| to store data while minting \verb|my-data.hello.os| in order to mint sub-entries beneath it, should one desire to do so.

Data is stored as bytes inside the contract map.
The owner of a namespace entry is the only address that can modify the data stored at that entry.
The interpretation of stored bytes is the responsibility of the protocol reading and writing from that entry.
Data can be mutable or immutable.
All data is public.
Protocols that wish to operate on private data may store hashes at namespace entries, or alternatively operate within the end-to-end encrypted Kinode networking protocol.

\subsection{Ownership and Transferring}

TODO

\subsection{Token-Bound Accounts}

Each namespace entry that does not store data, i.e. does not have a \verb|~| prefix, is an ERC-6551\footnote{A standard which allows ERC-721 NFTs to have an attached Ethereum account:  https://eips.ethereum.org/EIPS/eip-6551} token-bound account.
This means that namespace entries are automatically endowed with a wallet, controlled by their owner, for receiving, holding, and sending digital assets that live on the same chain as kimap.
The address of each entry's token-bound account is deterministic based on the path value.
Thus, before a path is even minted, one can send assets to its future wallet address or otherwise operate on it.

Token-bound accounts are self-evidently useful but become particularly powerful when combined with the KNS protocol to given every node identity an attached wallet.

\subsubsection{Creation and Use}

A token-bound account is created automatically for every non-tilde-prefixed kimap entry.
The address of the account is deterministically generated based on the full path of the entry.
The owner of the entry has the ability to operate the account.
TODO add more here

\subsection{Extensibility}
\label{sec:extensibility}

Kimap is designed to be generic and extensible.
Protocols such as KNS and the Kinode Package Manager extend kimap by placing special consideration on certain keys and interpreting the data stored at them in a particular way.
A specific description of how this works can be seen in the chapters for each of those protocols.

In the general case, a protocol specifies itself on kimap by declaring a set of \verb|~|-prefixed keys which are interpreted a certain way and endow certain properties to their parent key. For example, a protocol that aims to act as an motd ("message of the day") system may specify that the bytes stored at any \verb|~motd| key will be interpreted as a UTF-8 motd string for the parent key, which is perhaps a node identity in the KNS. If the owner of the key \verb|howdy.kino| wishes to participate in this protocol, it simply mints the key \verb|~motd.howdy.kino| and stores bytes there, perhaps \verb|[68 65 6c 6c 6f 20 77 6f 72 6c 64]|.

Extension of kimap is permissionless: any protocol may begin operating on the keys and data stored in the map simply by specifying itself.
Note that if two protocols use the same entry or entries to store data, key owners may be forced to choose between participating in one protocol or the other.
If an entry label is already in use by a popular protocol, developers creating a new protocol would be advised to either match the data format in current use for that entry label, or ensure non-overlap by prefixing/postfixing the entry label with a custom value.
For example, if the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it instead reads that label from \verb|~my-protocol-motd.howdy.kino|.

Another strategy for avoiding conflicts is to subdivide the namespace by storing a protocol's data entries at a nested path beneath the relevant entry.
If the key \verb|howdy.kino| is the entry-of-interest, and the motd protocol described above is in common use, a different protocol that wishes to use the \verb|~motd| entry label could specify that it reads that label from \verb|~motd.my-protocol.howdy.kino| rather than directly below.

%
%
%
\section{KNS, Kinode Name System}

Kinode Name System is a protocol built on top of kimap.
It transforms an entry in the kimap namespace into a \textit{node identity} for use in the Kinode network.
Node identities are central to the programming model of Kinode OS.
Usually manipulated as strings in a process, a node's identity is the first component of an \verb|address|, which uniquely identifies a specific process, part of a package, published by a (different) \verb|node_id|, running on that particular node.

\subsection{Specification}

The definition of a node identity in the KNS protocol is any kimap entry which has a:

\verb|~net-key| sub-entry AND (a \verb|~routers| sub-entry XOR (an \verb|~ip| sub-entry AND at least one of the following: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry)).

A sample of this protocol can be seen in fig. \ref{fig:example kimap}. Two classes of nodes are defined: \textit{direct} and \textit{indirect}. Direct nodes are those which publish an \verb|~ip| and one or more of the \verb|port| sub-entries. Indirect nodes are those which publish \verb|~routers|.

The data stored at \verb|~net-key| must be 32 bytes corresponding to an Ed25519 public key.
This is a node's signing key which is used across a variety of domains to verify ownership, including in the end-to-end encrypted networking protocol between nodes.
The owner of a namespace entry / node identity may rotate this key at any time by posting a transaction to kimap mutating the data stored at \verb|~net-key|.

The bytes at a \verb|~routers| entry must parse [TODO what encoding?] to an array of strings.
These strings should be node identities.
Each node in the array is treated by other participants in the networking protocol as a router for the parent entry.
Routers should themselves be direct nodes.
If a string in the array is not a valid node identity, or it is a valid node identity but not a direct one, that router will not be effective in the networking protocol.
Further discussion of the networking protocol specification is presented in the Networking section of the Kinode OS chapter.

The bytes at an \verb|~ip| entry must be 16 bytes corresponding [TODO clarify little or big endian] to a 128-bit unsigned integer.
This integer is translated to an IPv4 address if it is <32-bit.
Otherwise it is translated to an IPv6 address. [TODO clarify translation process]

Lastly, the bytes at any of the following port entries: \verb|~tcp-port| sub-entry, \verb|~udp-port| sub-entry, \verb|~ws-port| sub-entry, \verb|~wt-port| sub-entry must be 2 bytes corresponding to a 16-bit unsigned integer [TODO clarify little or big endian].
This integer is translated to a port number.
In practice, port numbers used are between 9000 and 65535.
Ports between 8000-8999 are usually saved for HTTP server use.

\subsection{Indexing}

Events emitted by kimap are used for indexing map data.
Luckily, Kinode OS provides all the primitives necessary to do so effectively.

TODO more here: include the event data types and what values are indexed such that they can be used as filters.

\subsection{Adding Other Onchain Identity Primitives}

The KNS is not an attempt at replacing or competing with existing onchain identity primitives such as ENS and Lens.
Rather, it is designed to satisfy the public key infrastructure needs of the Kinode network.
It is of paramount importance that nodes can initiate secure communication with one another without the use of any data-set other than what is available publicly onchain.
Peer-discovery middlemen induce centralization and complicate networking protocols.

The structure of kimap means that not only can KNS be designed not to compete with other identity primitives, it can also seamlessly integrate them.
As of this paper, this has already been done for ENS protocol.
Here is a brief description of the procedure to do so:
\begin{enumerate}
    \item A contract is created to allow owners, and only owners, of a given identity primitive to mint their corresponding name in a kimap namespace controlled by this contract.
    \item The top-level namespace entry corresponding to an outside identity primitive, \verb|lens| for example, is minted and transferred to this contract.
    \item If necessary, a LayerZero or other such cross-chain messaging protocol is configured to allow owners of an identity primitive on another chain to verify their ownership on the chain that kimap is deployed on.
    \item The final result is that the owner of, for example, \verb|myname.lens| can now register \verb|myname.lens| in kimap and use it as their PKI entry for Kinode.
\end{enumerate}

%
%
%
\section{Kinode OS}

This chapter discusses the architecture of Kinode OS. For a more "hands-on" description of the OS, including detailed programming examples and documentation, go to \href{https://book.kinode.org/}{book.kinode.org}.

Kinode OS is a process virtual machine run to operate a "node" on the Kinode network.
At its core, the virtual machine wraps around a Wasm runtime
\footnote{Wasm is specified at https://webassembly.github.io/spec. Kinode uses Wasm for processes because it is a highly performant, language independent, portable, and sandboxable compilation target.}
which executes all userspace code.
After a node identity is registered onchain in the KNS, the operator should boot the OS using the private key matching the public \verb|~net-key| posted in the kimap.
Once this has been done, if the networking details (routers, IP, etc) are properly read from chain and able to be matched by the runtime, that node is now "online".
Other nodes can now interact with the booted node through the Kinode networking protocol by reading its KNS node identity and using the data stored there.

The OS is developed and distributed by Kinode DAO. A formal specification of all aspects of the virtual machine is currently under development.
The runtime is as simple as possible, with a maximal amount of logic ejected to userspace and the rest stored in modules.
In the future, Kinode will benefit from "client diversity" as does a traditional blockchain: many implementations of the virtual machine
\footnote{The Wasm runtime is by a wide margin the most complex aspect of the OS, and at least a dozen such runtimes exist today, written in multiple languages.
This bodes well for future Kinode client diversity.}
will make the network more robust to potential bugs and decentralize the development process, leading to productive ossification of core features, resulting in stability and long-term strength.

While (generally) all packaged into a single executable, the OS can productively be described in 3 parts: a \textit{runtime}, a set of \textit{runtime modules}, and \textit{userspace}.
The "kernel" frequently referred to in this paper is in fact just a runtime module.

The runtime is a "native" (to whatever architecture it targets, which may be Unix, a browser, hardware...) program that manages node booting (including onchain registration) and (generally asynchronously or in parallel) executes the runtime modules.
Runtime modules are blocks of code written at the same level of abstraction as the runtime itself, but designed to resemble userspace processes.
These modules are registered in the kernel \textit{as} processes, meaning that they can be messaged by userspace in the system-wide request-response protocol and secured via capabilities.
Finally, userspace is comprised of all non-runtime-module processes executed virtually by the kernel.
These processes are always compiled to Wasm and comport to the Wasm Component Model\footnote{https://component-model.bytecodealliance.org/}.
They are adapted to the Kinode WIT file which defines the common interface that all processes must implement and provides a set of "system calls" afforded to userspace processes by the kernel.

The reference implementation built and maintained by the DAO is currently written in Rust, as are all the runtime modules.
It also comes with a number of pre-installed userspace packages that perform critical tasks.
In the future, other entities will likely seek to distribute their own implementations which may contain different pre-installed packages or even different runtime modules.

\begin{figure}
    \centering
    \begin{lstlisting}
    eth:distro:sys
    http_client:distro:sys
    http_server:distro:sys
    kernel:distro:sys
    kv:distro:sys
    net:distro:sys
    state:distro:sys
    terminal:distro:sys
    timer:distro:sys
    sqlite:distro:sys
    vfs:distro:sys
    \end{lstlisting}
    \caption{The full list of runtime modules in the OS distribution maintained by Kinode DAO as of this writing.}
    \label{fig:runtime modules list}
\end{figure}

\subsection{WIT}

Wasm Interface Type\footnote{https://component-model.bytecodealliance.org/design/wit.html}, or WIT, is a format to describe types and function definitions which can be used in a Wasm component.
Kinode OS uses a single WIT file to define the types shared across all processes and provide a number of functions.
The functions fall into 3 categories:
\begin{itemize}
    \item self-configuration
    \item capabilities management
    \item message I/O
\end{itemize}

WIT files are organized into worlds. All types and functions provided to Kinode processes are currently stored in one world labeled \verb|lib|.

\subsubsection{WIT Types}

Discussion of the types presented here will occur throughout the rest of the OS description.
Some types in kinode.wit are omitted for brevity.

\begin{figure}[htbp]
    \centering
    \begin{lstlisting}
    record process-id {
        process-name: string,
        package-name: string,
        publisher-node: node-id,
    }
    record address {
        node: node-id,
        process: process-id,
    }
    record lazy-load-blob {
        mime: option<string>,
        bytes: list<u8>,
    }
    \end{lstlisting}
    \caption{Basic types in kinode.wit}
    \label{fig:WIT Types 1}
\end{figure}

An \verb|address| globally identifies a process running on a particular node.

A \verb|process-id| identifies a particular process by its publisher, package name, and process name.

\begin{figure}
    \centering
    \begin{lstlisting}
    record capability {
        issuer: address,
        params: json,
    }
    \end{lstlisting}
    \caption{Capability type in kinode.wit}
    \label{fig:WIT Types 3}
\end{figure}

Capabilities are signed by the local kernel's \verb|~net-key|, turning them into unforgeable tokens of authority.

\begin{figure}
    \centering
    \begin{lstlisting}
    record request {
        inherit: bool,
        expects-response: option<u64>,
        body: list<u8>,
        metadata: option<json>,
        capabilities: list<capability>,
    }
    record response {
        inherit: bool,
        body: list<u8>,
        metadata: option<json>,
        capabilities: list<capability>,
    }
    variant message {
        request(request),
        response(tuple<response, option<context>>),
    }
    \end{lstlisting}
    \caption{Message type in kinode.wit}
    \label{fig:WIT Types 2}
\end{figure}

Messages are produced and consumed by Kinode processes. Further discussion in the Message Passing section.

\subsubsection{WIT Host Functions}

WIT host functions must be implemented by the kernel.
The Wasm Component model allows these functions to be called by processes.

\begin{figure}
    \centering
    \begin{lstlisting}
    // self-configuration
    print-to-terminal()
    set-on-exit()
    get-on-exit()
    get-state()
    set-state()
    clear-state()
    spawn()

    // capabilities management
    save-capabilities()
    drop-capabilities()
    our-capabilities()

    // message I/O
    receive()
    get-blob()
    send-request()
    send-requests()
    send-response()
    send-and-await-response()
    \end{lstlisting}
    \caption{Host functions in kinode.wit}
    \label{fig:WIT Functions}
\end{figure}

\subsubsection{WIT Process Format}

The process format enforced by kinode.wit is remarkably simple: it imports the types and functions defined in the main library world, and requires processes to implement a single function: init.
\footnote{This does not preclude processes from implementing other functions.}

\begin{figure}
    \centering
    \begin{lstlisting}
    world process {
        include lib;
        export init: func(our: string);
    }
    \end{lstlisting}
    \caption{Process world in kinode.wit}
    \label{fig:Process world}
\end{figure}

Init serves as the entry point for a process.
The kernel begins execution of a process by calling init.
When init returns, the process will cease execution.
\footnote{All processes are single-threaded. To perform parallel computation, one can spawn child processes.}

\subsection{Microkernel}

Every aspect of the operating system, including the kernel itself, comports to a set of messaging rules defined by the microkernel\footnote{https://wiki.osdev.org/Microkernel} which is responsible for five things:
\begin{enumerate}
    \item Using a Wasm runtime
    \footnote{The reference implementation currently uses \href{https://wasmtime.dev}{Wasmtime}.}
    to execute compiled processes which implement the Kinode WIT standard, where execution includes managing their memory usage.
    \item Implementing the host functions, exposed to all processes, defined in Kinode WIT standard.
    \item Implementing the kernel API that allows processes with kernel-messaging capabilities to perform aspects of process management.
    \item Passing messages between all processes including to/from the kernel itself.
    \item Enforcing messaging capabilities.
\end{enumerate}

Messaging capabilities are a subset of the capabilities security model defined by the OS, issued by the kernel process, \verb|kernel:distro:sys|.
Each process can mark itself as either \verb|public| or \verb|private| at instantiation.
Public processes can be messaged by any other process.
Private processes, as enforced by the kernel, require that the message source holds their messaging capability.
See the capabilites section of this chapter for details on their use and how capabilities apply to processes running a remote node.

As of this writing, the kernel runtime module in Kinode DAO's implementation of the OS fits into about 2,700 lines of Rust.

\subsection{Message Passing}

A message between two Kinode processes is either a request or a response, as seen in the WIT definitions.
A message has a single source \verb|address| and a single target \verb|address|.

If the node identity indicated in the target \verb|address| matches that of the local kernel or is simply the string \verb|our|, the message is routed directly through the kernel to the target (assuming the source has the capability to message the target or the target is public).
Otherwise, the message is routed through the networking protocol to the remote node indicated.

Ordering of messages between a given source and a given target is enforced by both kernel and networking protocol.
Messages are not otherwise ordered, meaning that if process A sends messages 1, 2, 3 to process B, and process B sends messages 4, 5, 6 to A, no guarantees are enforced other than that process B will receive messages 1, 2, 3 in that order and process A will receive 4, 5, 6 in that order.
If process C sends message 7 to A, it may be received before 1, after 3, or somewhere in between.



\subsection{Capabilities-Based Security}
\subsection{System Primitives}
\subsection{Example Process}
\subsubsection{Virtual Filesystem}
\subsubsection{Networking}
\subsubsection{HTTP Client \& Server}
\subsubsection{ETH RPC}
\subsubsection{SQLite, KV-Store}
\subsection{Extensions}

Wasm is an excellent compilation target for processes.
Processes are naturally sandboxed and cross-platform.
However, there are also costs associated with Wasm.
For example, not all libraries can be compiled to Wasm and hardware support for accelerators like GPUs is currently lacking.
Extensions supplement and compliment Kinode processes, removing these constraints, while maintaining the advantages associated with Kinode, e.g., the request/response system.

Extensions are WebSocket clients, written in any language and run natively alongside Kinode, that connect to a paired Kinode process.
The paired process serves as the interface between the extension and the rest of the Kinode system.

Extensions can be written in any language and can use any library, since an extension is just a native program that can connect to Kinode as a WebSocket client and that implements a certain protocol.

The cost of extensions is that they are not as easy for users to install and use.
Since they are native, rather than Wasm, they will not run on arbitrary systems.
They are also not as easy to distribute as packages.
Therefore only sophisticated users should be expected to run extensions, since they will either need to compile them themselves or set up and maintain an additional program running next to Kinode.

\subsection{Backwards Compatibility}
%
%
%
\section{Package Manager}

Like KNS, the Kinode Package Manager is a protocol deployed on kimap.
It is another protocol critical to the operation of Kinode OS.
As described in the Kinode OS chapter, the userspace presented by the OS is comprised of processes, which are bundled into packages.
There is no built-in method for managing the packages installed in a node.
Rather, userspace programs with the required capabilities must save packages in the virtual filesystem and prompt the kernel to start running certain processes.
The kernel has no built-in concept of a "package".

If a process has the necessary capabilities, they may create requests to and receive responses from \verb|kernel:distro:sys| like any other process.
The kernel specifies a request type that includes commands relevant to managing processes.
Programs that wish to "install" and "uninstall" packages merely submit these requests.
These programs must also have advanced capabilities to access the virtual filesystem, such that they can create new top-level directories formatted in such a way that the kernel can access compiled \verb|.wasm| files that contain a single process.

By convention, packages are stored in a \verb|.zip| file with the name of the package (package name [colon] publisher node id).
The top level of the zipped directory contains a \verb|metadata.json| file, a \verb|pkg| directory, and a directory for each process defined in the \verb|pkg| directory.
The \verb|pkg| directory defines processes by
\begin{enumerate}
    \item containing a \verb|.wasm| file, the name of which matches the process name
    \item optionally declaring the process in a file named \verb|manifest.json|, which defines the processes in the package that should be ran upon installation.
\end{enumerate}

\verb|pkg| may also contain a \verb|scripts.json| file which defines a list of processes that can be ran as scripts.
Scripts are merely processes which, by convention, can be executed from the system terminal, run for some period of time, and optionally return a final response before exiting which the terminal may print.

It is important to note that all of the above logic exists outside of the kernel and runtime.
A package's directory, metadata, and manifest are all interpreted by userspace code and boiled down to a series of kernel commands including \verb|InitializeProcess|, \verb|RunProcess|, and \verb|KillProcess|.
Of course, Kinode OS would not be very useful without this logic, and so the distribution maintained by the DAO comes with a combination app store and package manager called \verb|app_store:sys|.
Note that the publisher name, \verb|sys|, is not a node identity.
The publisher value in a package name is not enforced by the kernel.
It is accepted uncritically, and it is again the responsibility of the userspace package manager to assert a valid publisher if desired.

\subsection{Specification}

The userspace app store / package manager maintained by Kinode DAO uses an onchain protocol running on kimap to enable app discoverability and ranking.
The definition of a package (interchangeably called an "app") in this protocol is any kimap entry which has both of the following sub-entries:

\verb|~metadata-hash|, \verb|~metadata-uri|.

The publisher name of a package is the parent-parent entry.
The package name is the last path item in the parent entry.

A \verb|~metadata-hash| entry must contain 32 bytes corresponding to a SHA-256 hash of the \verb|metadata.json| file used to install a package.

A \verb|metadata-uri| entry may contain a UTF-8 string [TODO confirm this] corresponding to a Uniform Resource Identifier where one may access the metadata file for which the hash is contained in \verb|~metadata-hash|.

\begin{figure}
    \centering
    \begin{lstlisting}
    os
        foo
            ~ip
            ~ws-port
            ~net-key
            foos-app
                ~metadata-hash
                ~metadata-uri
    kino
        bar
            baz
                ~metadata-hash
                ~metadata-uri
            bam
                ~net-key
                ~routers
                ~metadata-hash
                ~metadata-uri
                boozle
                    ~metadata-hash
                    ~metadata-uri
    \end{lstlisting}
    \caption{Example kimap with multiple packages present.}
    \label{fig:example kimap with packages}
\end{figure}

In Fig. 2 there are 4 packages present: \verb|foos-app:foo.os|, \verb|baz:bar.kino|, \verb|bam:bar.kino|, and \verb|boozle:bam.bar.kino|.
Note that the parent path from a valid package sub-entry contains the entire package name including publisher.
Note also that a publisher does not need to be a valid node identity as defined in the KNS protocol, though in practice it likely will be.
A single publisher providing multiple packages can do so by minting sub-entries corresponding to those packages' names.
Lastly, a package may also itself be a node identity as demonstrated in \verb|bam.bar.kino|.
This is a good example of how protocols in kimap's global namespace interact and overlap with one another.

\subsection{Default-distro App: App Store}

As noted, Kinode DAO's distribution of the OS comes with an app store.
This package is named \verb|app_store:sys|.
The \verb|main| process, \verb|main:app_store:sys|, indexes kimap to identify packages onchain, manages the installation of packages using kernel commands, and presents a web UI for a node operator to browse, install, and manage packages (generally labeled as "apps" in the frontend).

The app store also uses \$KINO to enable ranking and filtering of available apps.
A common failure mode of distributed networks is that content becomes saturated and global curation is impossible without re-centralization. [TODO explain]


[TODO provide spec for metadata.json, manifest.json, scripts.json]

%
%
%
\section{KINO Token}

\$KINO is a utility token designed to fill two roles in the Kinode network: assignment of \textbf{relative value in the global namespace} and \textbf{namespace and protocol governance}.
The token operates alongside the kimap contract–"What you guys are referring to as KINO, is in fact, kimap/KINO, or as I've recently taken to calling it, kimap plus KINO."

\subsection{Binding to kimap Namespace}

A token holder may choose to \textit{bind} \$KINO to an entry in kimap.
To bind \$KINO, a token holder submits a transaction to the kimap contract specifying the amount of \$KINO to bind and the target entry.
Data-storing entries (prefixed with \verb|~|) cannot be a target for binding.
Any other entry is a valid target, from top-level entries to arbitrarily deeply nested entries.

Binding is performed in order to produce a value-weighted onchain directory of nodes, apps, and other content.
Every protocol built on kimap can automatically benefit from the binding of \$KINO to keys to create a rankable listing data structure and market for user attention.
Binding may also beget protocol rewards, which are assigned to the owner of the namespace entry, \textbf{not} the address which owns the bound tokens.
This mechanism allows protocols on kimap to encourage and incentivize users to bind tokens to entries that are not their own.

\subsection{Unbinding}

\$KINO can be unbound from a kimap entry at any time by the address which initially bound it.
Unbinding is performed via a transaction to the kimap contract specifying the amount of \$KINO to unbind and the target entry.
Note that multiple addresses can bind to the same kimap entry at any given time, meaning that various addresses may hold a claim to unbind \$KINO from an entry. Since the total amount of \$KINO bound to an entry will always be exactly equal to the sum of the claims by all addresses, the order of binding and unbinding operations is not contentious.

\subsection{Discussion}

As described in its chapter, kimap addresses the discoverability problem in peer-to-peer programming by allowing participants to claim paths and post data to a global hierarchical namespace.
However, this mass of bytes is near-useless without a \textit{weighting mechanism} that can be used programmatically or manually to evaluate content for relative value.

Consider the operation of a web search engine.
First, content is crawled and indexed.
In the indexing process, semantic and relative value is assigned to a given piece of content.
These weights are then used during a given search to provide a ranked set of content objects which best match the search query.
Kimap combined with \$KINO is not itself a search engine, but it does provide the substrate to operate search engines and similar mechanisms in a decentralized way.
The entries in the map are content, and bound \$KINO is a weight-primitive which applies a topology to that content.

This substrate offers a significant improvement over its centralized counterpart in that incentives are aligned between users and providers.
A "provider" can be considered any party which places entries in the global namespace.
This group near-universally seeks to optimize for visibility, which is a zero-sum competition with others in the same group.
A "user" can be considered any "set of eyes" on the namespace (though not necessarily human eyes), which providers compete over.
Historically, both providers within and the operator of a centralized directory object have been incentivized to abuse the attention of users.
Additionally, operators have been incentivized to unfairly extract from providers, devising schemes such as placing a competitor's entries above a provider unless a special fee is paid.
Providers abuse attention in a similar manner by bribing operators to weight their content higher in areas where it's not actually relevant to the user.

These inefficiencies appear unavoidable in the modern web.
The kimap architecture combined with a single weighting mechanism publicly shared between users and providers presents an alternative in which all parties are forced to compete fairly.
Users, too, are empowered to reward and punish entries in the global namespace.
Because \textit{any address} can bind to \textit{any namespace entry}, the ability of a single provider to spend tokens on their irrelevant or otherwise spam-like entry is washed out by the broader ability of users to reward valued content by binding to it.

Meanwhile, the "operator" role is neutralized.
Kinode DAO is responsible for maintaining the namespace but has no control over the operation of a namespace entry held by another party or the binding/unbinding operations.
The DAO is also naturally incentivized to increase the value of \$KINO by not interfering with its use as a weighting mechanism.
Any "thumb on the scale" by the namespace operator would be visible onchain and immediately impact the value of the neutral weighting mechanism.

Because it is generic, the kimap+KINO substrate does not include a built-in algorithm to execute "search" or any other ranking strategy on its weights and values.
There is no single algorithm that will apply to the entire kimap.
Algorithms will instead be written for specific protocols running on kimap.
These will have access to \$KINO bindings as one tool in determining quality rankings, and many will also take into account other factors.
At the time of this writing, it is impossible to predict the specifics of algorithms that will enter popular use for evaluating protocols on kimap.

Now, we must discuss two known risks facing kimap+KINO.
One may note that the onchain primitives described in this paper are remarkably simple.
Binding and unbinding tokens does not require any game theory or MEV protection properties.
Registering and mutating namespace entries is also not subject to adversarial conditions, since the ability to do so is only granted to an entry's owner.
\footnote{However, that does not mean the same is true for contracts that utilize the protocol.
Kimap and KINO are designed to be modular–as described at length elsewhere in this paper, much of the utility of the protocol will come from contracts deployed "on top" to manage a given namespace, generate yield, and many other activities.
These contracts must be designed carefully to avoid failure modes common to onchain protocols.
For example, if one deploys a contract to manage a top-level namespace that wishes to allow for anyone to register a new sub-entry as their node ID, and exposes a function to claim any name, it would be trivially easy for someone else to front-run that transaction and "steal" the name.
A simple solution is to have the user commit to a hash of their desired name such as \href{https://docs.ens.domains/registry/eth\#commit-reveal}{ENS does}.}
As a result, we have very little to discuss regarding protocol risk, assuming the protocol is implemented properly\footnote{audits pending at the time of this writing}.
Instead, the risks presented are a combination of social and game-theoretic regarding the adoption of both kimap and \$KINO for their intended use.

The first risk is that kimap does not inspire developers to built on it.
As a new namespace primitive, it is an uphill battle to overcome network effects of existing namespaces.
We have worked to avoid this conflict by implementing and encouraging integrations with existing onchain namespaces that already have network effects.
This risk is also addressed by working to make Kinode OS a more attractive development target.
Since Kinode OS is extremely tightly integrated with kimap+KINO by default, adoption of Kinode OS will carry through to kimap.
There is also a possibility that Kinode OS enters widespread use but for some reason does not lead developers to building on top of kimap, instead preferring to deploy on other namespace systems or perhaps create their own on a per-protocol basis.
While this seems unlikely, such a scenario would likely encourage Kinode DAO to propose changes in order to re-align the two aspects of the project.

The second risk is if kimap enters widespread use, but for some reason, \$KINO is an unpopular value-weighting system for the namespace.
It is possible for algorithms operating on kimap to use other weight systems, even including a binding/unbinding system deployed by someone else that uses an entirely different token.
Kimap algorithms will undoubtedly, in many cases, take factors other than just the amount of \$KINO bound into account when ranking and filtering entries.
If another digital asset, token or otherwise, began to dominate these algorithms, it would have a negative impact on the value of \$KINO.
This outcome is protected against by effectively distributing ownership of \$KINO between many different kinds of users.
If users, providers, and the operator (the DAO) are all incentivized via protocol ownership, \$KINO will remain an extremely powerful Schelling point for its intended purpose.

\subsection{Rewards}

Why would a user, or anyone for that matter, bind tokens to a namespace entry?
Two broad categories of reasoning, "natural" utility and "augmented" value, combine to justify the binding action.

\subsubsection{Natural Utility}

Binding tokens offers an automatic value to the owner of the bound namespace by enhancing their property's relative value and ranking in the various algorithms running on the namespace.
For this reason, owners of a namespace entry will be naturally incentivized to bind their tokens to their namespace.
This will manifest itself differently across different protocols running on kimap.
In the Kinode Name System, tokens bound to a node identity enable spam-prevention algorithms, preferential routing algorithms, and many others.
The mere social incentive to connect value to an identity namespace entry will likely inspire significant amounts of binding.
We expect this dynamic to play out not such for KNS entries, but also for a number of other social or social-adjacent protocols that naturally fit into the kimap architecture.

\subsubsection{Augmented Value}

Yield is not an inherent aspect of Kinode's onchain footprint.
As noted above, the onchain Kinode protocol is simple.
More complex elements such as onchain yield are expected to be built on top of kimap+KINO.

One way this is likely to occur is through yield mechanisms designed to reward users for binding \$KINO to a specific namespace entry. Other possibilities for augmented binding value are protocol-specific airdrops, profit distribution schemes, and protocols which enable users to earn value through binding some amount of tokens and then providing a service offchain (for example, a compute-provider network that provides completions-as-a-service using a particular large language model, which required providers to bind a certain number of tokens to their own node identity through a contract in order to produce a reputational slashing mechanism).

Lastly, binding \$KINO emits \$veKINO, discussed later.
Ownership and utilization of \$veKINO can augment the value of binding via DAO-mediated rewards for governance participation.

\subsection{Emissions}

2\% for X years, then 0. [TODO expand on this]

\subsection{Current and Future Uses}

\$KINO is currently used by both KNS and the Kinode package manager protocol to address spam, provide a ranking/sorting system, and enable value accrual.

One interesting option available to protocols on kimap not demonstrated by the protocols in this paper is the ability to discriminate between top-level domains.
It is not required that a protocol apply itself to the entire kimap.
Instead, a protocol may define itself as only being valid within a single top-level domain, a subset of top-level domains, or even a subset of entries at some arbitrary level of nesting.
This may prove to be an ideal way to run protocols in a future where kimap is very large and indexing the entire map is more difficult than indexing a subset of it.

%
%
%
\section{veKINO Token}

Binding \$KINO mints an equivalent amount of \$veKINO to the address which performs the binding.
\$veKINO is a non-transferable vote-escrow token used by Kinode DAO to execute governance proposals.
This is not an empty role–unlike purely onchain protocols, which often fail to benefit from active governance, Kinode governance includes ongoing responsibilities over the namespace and protocol.

Decentralized finance protocols generally benefit from maximal immutability: once a stable and useful primitive exists, its value only tends to decay with changes.
For this reason, "governance" as applied to purely onchain protocols has historically been somewhat weak.
There is no governance necessary if a protocol is truly immutable and permissionless. \textbf{Kinode is not a purely onchain protocol}, however, and has a significant governance burden which must be executed in a decentralized matter for the network to be stable, neutral, and permissionless.

While the DAO will be strongly incentivized by builders to remain permanently backwards-compatible (meaning that protocols launched on Kinode will never be forced to apply an upgrade), additive non-breaking aspects will likely be added to the protocol on a regular basis to keep pace with the fast-moving world of software. The namespace also requires active governance in order to extract fair value from TLD purchasers and to prevent abuse.

\subsection{Creating Proposals}

TODO

\subsection{Voting and Rewards}

TODO

\subsection{Delegation}

Rather than complicate the namespace and voting mechanisms with built-in onchain delegation, Kinode governance leverages the power of personal nodes to enable offchain vote delegation.
Users who wish to delegate their vote to another member may run software in their Kinode voting app to simply match the behavior of that other namespace entry onchain.
This allows users to be rewarded for participation while retaining full control of their vote.
The DAO (and possibly large voting entities) also has the ability to run paymaster server(s) to allow for free governance participation in this way.
Users may perform a one-time approval to execute votes through a paymaster leveraging account abstraction for “free” voting.

\subsection{Default-distro App: Governance Portal}


%
%
%
\section{Kinode DAO}

If Kinode were a shape, it would be a triangle:

\begin{figure}
    \centering
    \begin{tikzpicture}
    \draw (0,3) node[fill=yellow!80!black]{$kimap+KINO$}
    -- (4,3) node[fill=yellow!80!black]{$Kinode OS$}
    -- (2,0) node[fill=yellow!80!black]{$Kinode DAO$}
    -- cycle;
    \end{tikzpicture}
    \caption{The Triangle}
    \label{fig:triangle}
\end{figure}

\subsection{Governance Structure}
\subsection{TLD Management}
\subsubsection{Auction Types}
\subsubsection{Profitability}
\subsection{Other Duties}
%
%
%
\section{A Kinode Future}

The primary success metric for Kinode is the number of protocols operating on the network.
A Kinode protocol can include an onchain element, whether it is a protocol inside kimap or otherwise.
A Kinode protocol will always include an offchain peer-to-peer element: a software package that one can run on their node.

The secondary success metric for Kinode is the number of nodes online in the network.
Nodes can run anywhere: by a user in their home, in a data center, or on a mobile device.
Nodes will execute the Kinode OS specification, but be virtualized by a diversity of runtimes optimized for different environments.

In a Kinode future, the web as we know it today is replaced by a tapestry of permissionless protocols that combine the sovereignty of peer-to-peer with the power of industrial-scale computing.
Via runtime extensions and controlled namespaces, today's first-party platforms will transform into modularized protocols where users tap into centrally-operated services à la carte.
A new generation of protocols will be built p2p-first, allowing anyone to act as a provider of powerful services like AI image, text, and video producers or high-speed anonymous networking.

These protocols will not be developed by massive teams or require brigades of DevOps workers to stay online.
A small group of programmers will specify their design, create an implementation, and publish it onchain.
They may choose to enable future upgrades by decentralizing the governance of their specification with a DAO and token, or simply allow its permissionless use forever in a final state.
Switching between protocols will be a trivially easy process for users.
The monopoly of ossified web protocols will be obliterated by Kinode's user-node architecture, which allows for the operation of "transformer" protocols that enable vampire-attacks on any existing protocol with no technical knowhow on the side of the user.

Mainstream technology will continue to evolve rapidly at both the hardware and software level. New programming languages and new chips will emerge that continue to improve on performance and security.
Kinode is a beneficiary of this innovation, and at the same time, it unleashes the potential of new computing capabilities while maintaining the sovereignty of the end user.

\end{document}
